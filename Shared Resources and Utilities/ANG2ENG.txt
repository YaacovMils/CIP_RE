(*!
@purpose
This program (`ANG2ENG.txt`) is responsible for handling the conversion of raw analog input signals into meaningful engineering units. It reads integer values from various analog input modules (`%AI`) representing physical properties like conductivity and temperature, scales them according to predefined ranges, and outputs the calculated values to global registers (`%R`) for use in other logic programs.

The core function is to translate the raw PLC count (e.g., 0-32000) from a sensor into a human-readable engineering value (e.g., 0-200 mS/cm for conductivity, 0-100 Â°C for temperature).

@inputs
- `AIT1005` (%AI0005) (INT): Raw analog input for Soda Tank 1/2 conductivity.
- `AIT1006` (%AI0006) (INT): Raw analog input for Acid Tank conductivity.
- `AIT1010` (%AI0010) (INT): Raw analog input for CIP Line A return conductivity.
- `AIT1011` (%AI0011) (INT): Raw analog input for CIP Line B return conductivity.
- `AIT1012` (%AI0012) (INT): Raw analog input for CIP Line C return conductivity.
- `TT1002` (%AI0002) (INT): Raw analog input for Acid Tank temperature.
- `TT1003` (%AI0003) (INT): Raw analog input for Soda Tank 1 temperature.
- `FQC1007` (%AI0007) (ARRAY OF WORD): Raw analog input for CIP Line C flow meter.

@outputs
- `C_A_CLC` (%R00124) (INT): Calculated conductivity for CIP Line A.
- `C_B_CLC` (%R00125) (INT): Calculated conductivity for CIP Line B.
- `C_C_CLC` (%R00126) (INT): Calculated conductivity for CIP Line C.
- `C_3_CLC` (%R00120) (INT): Calculated conductivity for the Acid Tank.
- `C_45CLC` (%R00119) (INT): Calculated conductivity for the Soda Tanks.
- `T_3_CLC` (%R00116) (INT): Calculated temperature for the Acid Tank.
- `T_4_CLC` (%R00117) (INT): Calculated temperature for Soda Tank 1.
- `T_5_CLC` (%R00118) (INT): Calculated temperature for Soda Tank 2.
- `A_FLOW` (%R09006) (ARRAY OF WORD): Scaled flow rate for CIP Line C.

@notes
- This code is for a GE/Emerson RX3i PLC and is written in Structured Text (ST).
- The program uses a temporary DINT variable (`temp_DINT_for_AUX1`) overlaid on a WORD array (`AUX1`) to perform 32-bit multiplication and division for scaling, a common technique in PLCs with limited direct support for complex math on mixed data types.
- Many rungs contain logic that is permanently disabled (`IF _ALW_OFF THEN...`), which may be leftover from development or testing and is not currently active.
- The scaling logic is repetitive for each sensor, suggesting a standardized hardware and scaling configuration.
*)
VAR_GLOBAL
	_ALW_OFF AT %S00008 : BOOL; (* Always OFF *)
	_ALW_ON AT %S00007 : BOOL; (* Always ON *)
	AIT1005 AT %AI0005 : INT; (* SODA TANK 1,2 CONDUCTIVITY *)
	AIT1006 AT %AI0006 : INT; (* ASID TANK CONDUCTIVITY *)
	AIT1010 AT %AI0010 : INT; (* CIP "A" CONDUCTIVITY *)
	AIT1011 AT %AI0011 : INT; (* CIP "B" CONDUCTIVITY *)
	AIT1012 AT %AI0012 : INT; (* CIP "C" CONDUCTIVITY *)
	AUX1 AT %R00102 : ARRAY[0..4] OF WORD; (* Temp register 1 *)
	AUX3 AT %R00104 : DINT; (* Temp register 3 *)
	C_3_CLC AT %R00120 : INT; (* Calculated Cond in ACID brl *)
	C_45CLC AT %R00119 : INT; (* Calculated Cond in SODA 1/2 brl *)
	C_A_CLC AT %R00124 : INT; (* Calculated CIP A conductivity *)
	C_B_CLC AT %R00125 : INT; (* Calculated CIP B conductivity *)
	C_C_CLC AT %R00126 : INT; (* Calculated CIP C conductivity *)
	FQC1007 AT %AI0007 : ARRAY[0..3] OF WORD; (* CIP "C" FLOW *)
	R00420 AT %R00420 : REAL; (* No description provided *)
	R09001 AT %R09001 : INT; (* No description provided *)
	R09002 AT %R09002 : INT; (* No description provided *)
	R09003 AT %R09003 : INT; (* No description provided *)
	R09004 AT %R09004 : INT; (* No description provided *)
	R09005 AT %R09005 : INT; (* No description provided *)
	R09009 AT %R09009 : INT; (* No description provided *)
	R09010 AT %R09010 : INT; (* No description provided *)
	R09011 AT %R09011 : INT; (* No description provided *)
	T_3_CLC AT %R00116 : INT; (* Calculated Temp in ACID brl *)
	T_4_CLC AT %R00117 : INT; (* Calculated Temp in SODA1 brl *)
	T_5_CLC AT %R00118 : INT; (* Calculated Temp in SODA2 brl *)
	TT1002 AT %AI0002 : INT; (* ASID TANK TEMPERATURE *)
	TT1003 AT %AI0003 : INT; (* SODA TANK 1 TEMPERATURE *)
	A_FLOW AT %R09006 : ARRAY[0..3] OF WORD; (* A flow meter *)
	temp_DINT_for_AUX1 AT %R00102 : DINT; (* Helper variable for DINT operations on the memory occupied by AUX1. *)
END_VAR

(* Rung 1: COMMENT0 *)

(* Rung 2: Prepares the scaling calculation for CIP A conductivity by clearing the temporary register `AUX1`, moving the raw analog value `AIT1010` into `AUX1[0]`, and setting the scaling factor (200) in `AUX1[2]`. *)
AUX1[0] := 0;
AUX1[1] := 0;
AUX1[2] := 0;
AUX1[3] := 0;
AUX1[0] := AIT1010;
AUX1[2] := 200;

(* Rung 3: Performs the scaling calculation for CIP A conductivity. The raw value in `AUX1[0]` is multiplied by the scaling factor in `AUX1[2]` (200) and then divided by the maximum raw value (32000). The result is stored back in `AUX1[0]`. *)
temp_DINT_for_AUX1 := temp_DINT_for_AUX1 * AUX3;
temp_DINT_for_AUX1 := temp_DINT_for_AUX1 / 32000;

(* Rung 4: Moves the scaled CIP A conductivity value from the temporary register `AUX1[0]` to its final destination `C_A_CLC` for use in the CIP A logic, and also to `R09009` for HMI display. *)
C_A_CLC := AUX1[0];
R09009 := C_A_CLC;

(* Rung 5: COMMENT1 *)

(* Rung 6: Prepares the scaling calculation for CIP B conductivity by clearing the temporary register, moving the raw analog value `AIT1011` into `AUX1[0]`, and setting the scaling factor (200). *)
AUX1[0] := 0;
AUX1[1] := 0;
AUX1[2] := 0;
AUX1[3] := 0;
AUX1[0] := AIT1011;
AUX1[2] := 200;

(* Rung 7: Performs the scaling calculation for CIP B conductivity. *)
temp_DINT_for_AUX1 := temp_DINT_for_AUX1 * AUX3;
temp_DINT_for_AUX1 := temp_DINT_for_AUX1 / 32000;

(* Rung 8: Moves the scaled CIP B conductivity value to `C_B_CLC` and `R09010`. *)
C_B_CLC := AUX1[0];
R09010 := C_B_CLC;

(* Rung 9: COMMENT2 *)

(* Rungs 10-12: Scales the raw analog input for CIP C conductivity (`AIT1012`) into engineering units. This logic is identical to the scaling for CIP A and B. *)
AUX1[0] := 0;
AUX1[1] := 0;
AUX1[2] := 0;
AUX1[3] := 0;
AUX1[0] := AIT1012;
AUX1[2] := 200;

(* Rung 11: Performs the scaling calculation for CIP C conductivity. *)
temp_DINT_for_AUX1 := temp_DINT_for_AUX1 * AUX3;
temp_DINT_for_AUX1 := temp_DINT_for_AUX1 / 32000;

(* Rung 12: Moves the scaled CIP C conductivity value to `C_C_CLC` and `R09011`. *)
C_C_CLC := AUX1[0];
R09011 := C_C_CLC;

(* Rung 13: COMMENT3 *)

(* Rungs 14-16: Scales the raw analog input for the Soda Tank conductivity (`AIT1005`) into engineering units. *)
AUX1[0] := 0;
AUX1[1] := 0;
AUX1[2] := 0;
AUX1[3] := 0;
AUX1[0] := AIT1005;
AUX1[2] := 1000;

(* Rung 15: Performs the scaling calculation for the Soda Tank conductivity. *)
temp_DINT_for_AUX1 := temp_DINT_for_AUX1 * AUX3;
temp_DINT_for_AUX1 := temp_DINT_for_AUX1 / 32000;

(* Rung 16: Moves the scaled Soda Tank conductivity value to `C_45CLC` and `R09004`. *)
IF _ALW_ON AND NOT _ALW_OFF THEN
	C_45CLC := AUX1[0];
	R09004 := AIT1005 / 32;
END_IF;

(* Rung 17: COMMENT4 *)

(* Rung 18 *)
IF _ALW_OFF THEN
	R00420 := INT_TO_REAL(AIT1006);
END_IF;

(* Rung 19 *)
IF _ALW_OFF THEN
	R00420 := (R00420 * 10000.0) / 32000.0;
END_IF;

(* Rung 20: Calculated Cond in ACID brl *)
IF _ALW_OFF THEN
	C_3_CLC := TRUNC(R00420);
END_IF;

(* Rungs 21-23: Scales the raw analog input for the Acid Tank conductivity (`AIT1006`) into engineering units. *)
AUX1[0] := 0;
AUX1[1] := 0;
AUX1[2] := 0;
AUX1[3] := 0;
AUX1[0] := AIT1006;
AUX1[2] := 10000;

(* Rung 22: Performs the scaling calculation for the Acid Tank conductivity. *)
temp_DINT_for_AUX1 := temp_DINT_for_AUX1 * AUX3;
temp_DINT_for_AUX1 := temp_DINT_for_AUX1 / 32000;

(* Rung 23: Moves the scaled Acid Tank conductivity value to `C_3_CLC` and `R09005`. *)
C_3_CLC := AUX1[0];
R09005 := C_3_CLC;

(* Rung 24: COMMENT5 *)

(* Rungs 25-27: Scales the raw analog input for the Acid Tank temperature (`TT1002`) into engineering units. *)
AUX1[0] := 0;
AUX1[1] := 0;
AUX1[2] := 0;
AUX1[3] := 0;
AUX1[0] := TT1002;
AUX1[2] := 100;

(* Rung 26: Performs the scaling calculation for the Acid Tank temperature. *)
temp_DINT_for_AUX1 := temp_DINT_for_AUX1 * AUX3;
temp_DINT_for_AUX1 := temp_DINT_for_AUX1 / 32000;

(* Rung 27: Moves the scaled Acid Tank temperature value to `T_3_CLC` and `R09001`. *)
T_3_CLC := AUX1[0];
R09001 := T_3_CLC;

(* Rung 28: AI3 0-200 Soda Temperature *)

(* Rungs 29-31: Scales the raw analog input for the Soda Tank 1 temperature (`TT1003`) into engineering units. *)
AUX1[0] := 0;
AUX1[1] := 0;
AUX1[2] := 0;
AUX1[3] := 0;
AUX1[0] := TT1003;
AUX1[2] := 200;

(* Rung 30: Performs the scaling calculation for the Soda Tank 1 temperature. *)
temp_DINT_for_AUX1 := temp_DINT_for_AUX1 * AUX3;
temp_DINT_for_AUX1 := temp_DINT_for_AUX1 / 32000;

(* Rung 31: Moves the scaled Soda Tank 1 temperature value to `T_4_CLC` and `R09002`. *)
T_4_CLC := AUX1[0];
R09002 := T_4_CLC;

(* Rung 32: 28/12/2023 Canceled ************************************Soda Tank 2 ****************** *)

(* Rungs 33-35: Scales the raw analog input for the Soda Tank 2 temperature (`TT1003`) into engineering units. Note that this block is likely a copy-paste error, as it uses the same input as the Soda Tank 1 temperature calculation. *)
AUX1[0] := 0;
AUX1[1] := 0;
AUX1[2] := 0;
AUX1[3] := 0;
AUX1[0] := TT1003;
AUX1[2] := 200;

(* Rung 34: Performs the scaling calculation for the Soda Tank 2 temperature. Note the different divisor (31950 instead of 32000), which may be an attempt to calibrate the sensor. *)
temp_DINT_for_AUX1 := temp_DINT_for_AUX1 * AUX3;
temp_DINT_for_AUX1 := temp_DINT_for_AUX1 / 31950;

(* Rung 35: Moves the scaled Soda Tank 2 temperature value to `T_5_CLC` and `R09003`. *)
T_5_CLC := AUX1[0];
R09003 := T_5_CLC;

(* Rung 36: A flow meter *)
IF _ALW_OFF THEN
	(* Block Instruction Analysis: MOVE_INT
	 * Source: Variable FQC1007 at memory address %AI0007.
	 * Destination: Variable A_FLOW at memory address %R09006.
	 * Address Range: The instruction reads 3 words from the source address range %AI0007 to %AI0009 and writes them to the destination address range %R09006 to %R09008. *)
	A_FLOW[0] := FQC1007[0];
	A_FLOW[1] := FQC1007[1];
	A_FLOW[2] := FQC1007[2];
END_IF;

(* Rung 37: This logic appears to be a placeholder for scaling the flow meter input, but the multiplication and division by 1 have no effect. The logic is not currently active. *)
A_FLOW[0] := FQC1007[0];
A_FLOW[0] := A_FLOW[0] / 1;
A_FLOW[0] := A_FLOW[0] * 1;

(* Rung 38: A flow meter *)
IF _ALW_OFF THEN
	(* Block Instruction Analysis: MOVE_INT
	 * Source: Variable FQC1007[1] at memory address %AI0008.
	 * Destination: Variable A_FLOW[1] at memory address %R09007. *)
	A_FLOW[1] := FQC1007[1];
	A_FLOW[1] := A_FLOW[1] / 1;
	A_FLOW[1] := A_FLOW[1] * 1;
END_IF;

(* Rung 39: A flow meter *)
IF _ALW_OFF THEN
	(* Block Instruction Analysis: MOVE_INT
	 * Source: Variable FQC1007[2] at memory address %AI0009.
	 * Destination: Variable A_FLOW[2] at memory address %R09008. *)
	A_FLOW[2] := FQC1007[2];
	A_FLOW[2] := A_FLOW[2] / 1;
	A_FLOW[2] := A_FLOW[2] * 1;
END_IF;